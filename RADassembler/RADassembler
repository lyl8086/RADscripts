#!/bin/bash
shopt -s  expand_aliases 
alias tcmd="date '+%A %D %X'"
t0=$(date +%s)
Usage='

   ###############################################################################
   +                         RADassembler 1.10                                   +
   + A Pipeline For Assembly of PE RAD-seq (RPE) Reads from Multiple Individuals +
   +                Contact: liyulong12@mails.ucas.ac.cn                         +
   ###############################################################################
    
    -i: path to reads with enzyme cut sites of each individual, i.e. read1 files? 
        name as (individual name).fq[fa][.gz].
    -o: path to output.
    -s: path to paired-end reads of each individual, i.e. read2 files?
        name as (individual name_[12]).fq[fa][.gz].
    -P: PopMaP file.
    -f: type of input files. "fasta", "fastq", "gzfastq", "gzfasta".
    -M: minimum stack depth.
    -D: minimum read depth of a locus to export for assembly, also accept [lower:upper].
    -m: mismatch for ustacks.
    -n: mismatch for cstacks.
    -g: perform gapped assembly in stacks, 1 for ustacks, 2 for cstacks, 3 for all, 0 turn off.
    -c: individual coverage for a locus.
    -a: assembler, either "cap3" or "velvet", default cap3.
    -k: hash length for velvet, default 27.
    -A: turn off assembly.
    -R: run a single component, accept "ustacks", "cstacks" or "assembly".
    -t: number of threads.
    
    chooseM: Similarity threshold selection within individual [ustacks].
    chooseN: Similarity threshold selection across individuals [cstacks].
'
while getopts "i:o:s:m:M:n:f:P:D:t:R:c:g:a:k:hA" arg
do
    case $arg in
        i)
            in_path=$OPTARG     #file path.
            ;;
        o)
            out_path=$OPTARG    #out path.
            ;;
        s)
            samp=$OPTARG        #paired-end file path.
            ;;
        f)
            ftyp=$OPTARG        #file type.
            ;;
        M)
            minDP=$OPTARG       #minimum stacks depth.
            ;;
        m)
            mis=$OPTARG         #mismatch for ustacks.
            ;;
        n)
            c_mis=$OPTARG       #mismatch for cstacks.
            ;;
        g)
            gap=$OPTARG
            case $gap in
                1)
                    ugap='--gapped'
                    cgap=0
                    ;;
                2)
                    ugap=0
                    cgap='--gapped'
                    ;;
                3)
                    ugap='--gapped'
                    cgap='--gapped'
                    ;;
                0)
                    ugap=0;
                    cgap=0;
                    ;;
                ?)
                    ugap=''
                    cgap=''
                    ;;
            esac
            ;;
        P)
            map=$OPTARG         #PopMap file
            ;;
        D)
            minL=$OPTARG        #minimum locus depth for the export reads.
            ;;
        t)
            threads=$OPTARG
            ;;
        c)
            cov=$OPTARG
            ;;
        R)
            run_flg=$OPTARG
            ;;
        h)
            echo "$Usage"
            exit 0
            ;;
        A)
            asmb=0
            ;;
        a)
            assembler=$OPTARG
            ;;
        k)
            kmer=$OPTARG
            ;;
        ?)
            echo -e "\033[31m Unknown argument!\033[0m"
            exit 1
            ;;
    esac
done

###### Functions ######
function goto
{
    label=$1
    cmd=$(sed -n "/#$label:/{:a;n;p;ba};" $0)
    eval "$cmd"
    if [ $?==0 ]; then exit 0; else exit 1; fi
}

iter=0
function guess_fmt()
{

    if [ "$ftyp" == 'gzfastq' ];
    then
        suffix='fq.gz'
    elif [ "$ftyp" == 'fastq' ];
    then
        suffix='fq'
    elif [ "$ftyp" == 'fasta' ];
    then
        suffix='fa'
    elif [ "$ftyp" == 'gzfasta' ];
    then
        suffix='fa.gz'
    else
        iter=1
        f=`ls $1/$2*`
        if [ $? != 0 ];
        then
            echo -e "\033[47;31m File [prefix is $1/$2] not exists! \033[0m"
            echo -e "Quitting..."
            exit 1
        fi
        if [ ${f:0-6} == '.fq.gz' ];
        then
            ftyp='gzfastq'
            suffix='fq.gz'
        elif [ ${f:0-9} == '.fastq.gz' ];
        then
            ftyp='gzfastq'
            suffix='fastq.gz'
        elif [ ${f:0-6} == '.fa.gz' ];
        then
            ftyp='gzfasta'
            suffix='fa.gz'
        elif [ ${f:0-9} == '.fasta.gz' ];
        then
            ftyp='fasta'
            suffix='fasta.gz'
        elif [ ${f:0-3} == '.fq' ];
        then
            ftyp='fastq'
            suffix='fq'
        elif [ ${f:0-6} == '.fastq' ];
        then
            ftyp='fastq'
            suffix='fastq'
        elif [ ${f:0-3} == '.fa' ];
        then
            ftyp='fasta'
            suffix='fa'
        elif [ ${f:0-6} == '.fasta' ];
        then
            ftyp='fasta'
            suffix='fasta'
        else
            echo -e "\033[47;31m Unknown file format! [$f]\033[0m"
            echo -e "Quitting..."
            exit 1
        fi
    fi

}

function check_fmt() {
    
    if [ ! -f "$1/$2.$3" ];
    then
        ftyp=''
        echo -e "\033[47;31m File format is not correct, I'm guessing...\033[0m"
        guess_fmt $1 $2
    fi
}

function running_time() {

    t2=$(date +%s)
    prog=$1
    echo -e "\n====== $prog running time: $(( $t2 - $t1 )) s ======\n"
    t1=$t2
}

function read_popmap() {
    ###### Read PopMap ######
    while read line
    do
        key=`echo $line | awk '{print $1}'`
        val=`echo $line | awk '{print $2}'`
        if [ "$key" ] && [ "$val" ];
        then
            pop[$key]="$val"
        fi
    done < $1
}

function read_ind_order() {
    # read popmap and keep the order of individual.
    pop=''
    pop=(`awk '{print $1}' $1`)
}

function get_version() {
    ver=`$1 --version 2>&1 |head -1|awk '{print $2}'`
    f_ver=$(awk -v a=$ver 'BEGIN{ 
    if (a<2) {print 1} 
    else if (/Beta/) 
    {b=gensub(/.+Beta(.+)/,"\\1","g",a);
    if (b<9) {print 1} else {print 2}}
    else {print 2}}')
}

function gplot() {
local p=$1
local max1=$2+1
local xlab=$3
local ylab=$4
local mlab=$5
local name=$6
local asy=$7
local leg=$8                            # legend from head.
local yran=$9
if [ "$yran" ];
then
    max2=${yran#*:}
    min2=${yran%:*}
    min2=${min2:="GPVAL_Y_MIN-$max2*0.1"}
else 
    max2='GPVAL_Y_MAX+GPVAL_Y_MAX*0.1'
    min2='GPVAL_Y_MIN-GPVAL_Y_MAX*0.1'
fi
if [ "$leg" -eq 1 ];
then
    autoleg='set key autotitle columnhead'
else
    autoleg='unset key'
fi
if [ "$asy" -eq 1 ];
then
    asy="set arrow from 0,GPVAL_DATA_Y_MIN to $max1,GPVAL_DATA_Y_MIN lt 2 lw 2 lc rgb \"green\" nohead"
else
    asy=''
fi

gnuplot --persist << EOF
set terminal dumb size 100, 30
set key outside
$autoleg
unset label
set mytics 2
set xtics 1
set xrange [0:$max1]
set yrange [$min2:$max2]
set title "$mlab"
set xlabel "$xlab"
set ylabel "$ylab"
set xzeroaxis
plot $p
set terminal pdf noenhanced
set key inside
set output "$out/$name.pdf"
$autoleg
set yrange [$min2:$max2]
$asy
replot
set terminal png noenhanced 
set output "$out/$name.png"
replot
EOF
}

chooseM() {
    local file=$1
    local out=$2
    local mis=$3
    local threads=$4
    local minDP=$5
    local gap=$6
    local flag=$7
    local yrange=$8
    
    if [ $# -lt 4 ];
    then
        echo
        echo
        echo -e "\tSimilarity threshold selection for ustacks within individual\n"
        echo -e "\tUsage: RADassembler chooseM [infile] [outpath] [max mismatch] [threads] [minDP] [gapped] [replot] [yrange]"
        echo
        echo
        exit 0
    fi
    local name=`basename $file`
    local name=${name%.f*} # remove suffix f[ast][aq][.gz], may be bugs here.
    if [ ! -d $out ]; then mkdir $out; fi
    
    get_version 'ustacks'
    if [ "$f_ver" == 1 ];
    then
        if [ "$gap" == 1 ]; then gap='--gapped'; else gap=''; fi
    else
        if [ "$gap" == 0 ]; then gap='--disable-gapped'; else gap=''; fi
    fi
    
    if [ ! "$minDP" ]; then minDP=3; fi
    
    if [ -z "$flag" ];
    then
        echo -e "Mismatch\t1_allele\t2_alleles\t>=3_alleles" >$out/ustacks.stat
        for m in `seq 1 $mis`;
        do
            ustacks -f $file -o $out -p $threads -M $m -m $minDP -d -N 0 -H -i 1 $gap 2>&1 | tee -a $out/Ustacks.$m.log
            nparts=`zcat $out/$name*.snps.tsv.gz | head -2 | tail -1 | awk -F "\t" '{print NF}'` # test if new version for stacks.
            if [ "$nparts" == 10 ];
            then
                nloci=`zcat $out/$name*.snps.tsv.gz |tail -1 |cut -f3`
                zcat $out/$name*.alleles.tsv.gz |grep -v '^#' |cut -f3 |sort|uniq -c | \
                awk -v n=$nloci -v m=$m '{if($1==2){a++;} else if($1>2){b++;}} END {print m"\t"n-a-b"\t"a"\t"b;}' \
                >>$out/ustacks.stat
            elif [ "$nparts" == 9 ];
            then
                nloci=`zcat $out/$name*.snps.tsv.gz |tail -1 |cut -f2`
                zcat $out/$name*.alleles.tsv.gz |grep -v '^#' |cut -f2 |sort|uniq -c | \
                awk -v n=$nloci -v m=$m '{if($1==2){a++;} else if($1>2){b++;}} END {print m"\t"n-a-b"\t"a"\t"b;}' \
                >>$out/ustacks.stat
            else
                echo "Stacks files [$out/$name*.snps.tsv.gz] error!"
                exit 1;
            fi
        done
    fi
    dat="$out/ustacks.stat"
    plot="'$dat' using 1:2 with linespoints, '$dat' using 1:3 with linespoints, '$dat' using 1:4 with linespoints"
    
    gplot "$plot" "$mis" 'Mismatch' 'Number of loci' 'Similarity threshold within individual (ustacks)' 'chooseM_ustacks' 0 1 "$yrange"
}

chooseN() {
    # n is mismatch for cstacks
    local in=$1
    local out=$2
    local map=$3
    local max=$4
    local threads=$5
    local gap=$6
    local flag=$7                           # flag for replot.
    local yrange=$8                         # 

    tmp=''
    plot=''
    if [ $# -lt 5 ];
    then
        echo
        echo
        echo -e "\tSimilarity threshold selection for cstacks across individuals\n"
        echo -e "\tUsage: RADassembler chooseN [inpath] [outpath] [popmap] [max mismatch] [threads] [gapped] [replot] [yrange]"
        echo
        echo
        exit 0
    fi
    
    if [ ! -d $out ]; then mkdir $out; fi
    
    get_version 'cstacks'
    if [ "$f_ver" == 1 ];
    then
        if [ "$gap" == 1 ]; then gap='--gapped'; else gap=''; fi
    else
        if [ "$gap" == 0 ]; then gap='--disable_gapped'; else gap=''; fi
    fi
    
    if [ -z "$flag" ];
    then
        ##sort the individuals according to the num of loci.
        pop=(`cut -f1 $map`)
        len=${#pop[@]}
        for ((i=0;i<$len;i++));
        do
            indiv=${pop[$i]}
            nparts=`zcat $in/$indiv.snps.tsv.gz | head -2 | tail -1 | awk -F "\t" '{print NF}'`
            if [ "$nparts" == 10 ];
            then
                zcat $in/$indiv.snps.tsv.gz |tail -1 |cut -f3 >>$out/pop.loci
            elif [ "$nparts" == 9 ];
            then
                zcat $in/$indiv.snps.tsv.gz |tail -1 |cut -f2 >>$out/pop.loci
            else
                echo "Stacks file [$in/$indiv.snps.tsv.gz] error!"
                exit 1;
            fi
            #zcat $in/$indiv.models.tsv.gz |tail -1 |cut -f3 >>$out/pop.loci
        done
        paste $map $out/pop.loci >$out/pop.loci.1
        sort -k3,3nr $out/pop.loci.1 | cut -f1,3 >$out/pop.order
        rm $out/pop.loci.1 $out/pop.loci
        pop=(`cut -f1 $out/pop.order`)
        len=${#pop[@]}
        for ((i=0;i<$len;i++));
        do
            indiv=${pop[$i]}
            samp+="-s $in/$indiv "
        done
        ##################################################
        
        : >$out/catalog.num
        for m in `seq 1 $max`;
        do
            cstacks -n $m -o $out $gap -p $threads $samp 2>&1 | tee $out/Cstacks.$m.log #gapped
            echo "Mismatch=$m" >$out/$m
            grep "newly added" $out/Cstacks.$m.log |awk '{print $1}' >>$out/$m
            nparts=`zcat $out/*catalog.tags.tsv.gz | head -2 | tail -1 | awk -F "\t" '{print NF}'`
            if [ "$nparts" == 14 ];
            then
                zcat $out/*catalog.snps.tsv.gz | tail -1 | cut -f3 >>$out/catalog.num
            elif [ "$nparts" == 9 ];
            then
                zcat $out/*catalog.tags.tsv.gz | grep -v '^#' | wc -l >>$out/catalog.num
            else 
                echo "Stacks files [$out/*catalog.snps.tsv.gz] error!"
                exit 1;
            fi
            tmp+=" $out/$m"
            plot+="'$out/cstacks.stat' using (\$0+1):$m with linespoints, "
        done
    paste $tmp >$out/cstacks.stat
    rm $tmp
    else 
        for m in `seq 1 $max`;
    do
        plot+="'$out/cstacks.stat' using (\$0+1):$m with linespoints, "
    done
    fi
    let nind=$(cat $out/cstacks.stat|wc -l)-1
    gplot "$plot" "$nind" 'Individual index' 'Number of incremental loci' 'Similarity threshold across individuals (cstacks)' 'chooseN_cstacks' 1 1 "$yrange"
    plot="'$out/catalog.num' using (\$0+1):1 with linespoints"
    gplot "$plot" "$m" 'Mismatch' 'Number of loci' 'Number of total catalog loci' 'chooseN_cstacks_total' 1 0 "$yrange"

}

function run_ustacks() {
    local out_path=$1
    local mis=$2
    local minDP=$3
    local threads=$4
    local map=$5
    local len=${#indivs[@]}
    
    get_version 'ustacks'
    if [ ! -z "$ugap" ];
    then
        if [ "$ugap" == 0 ];
        then
            if [ "$f_ver" == 2 ]; then ugap='--disable-gapped'; else ugap=''; fi
        else
            if [ "$f_ver" == 2 ]; then ugap=''; fi
        fi
    fi
    for ((i=0;i<$len;i++));
    do
        indiv=${indivs[$i]}
        let j=$i+1
        # disable haplotype from secondry reads.
        ustacks -t $ftyp -f $indiv -H -N 0 $ugap -o $out_path/stacks/ -p $threads -M $mis -m $minDP -d -i $j 2>&1 | tee -a $out_path/stacks/Ustacks.log
        
    done
    tt=`grep 'ustacks is done.' $out_path/stacks/Ustacks.log`
    if [ -z "$tt" ];
    then
        echo -e "\033[47;31m Ustacks error! Quitting...\033[0m"
        exit 1
    fi
}

function run_cstacks() {
    local in_path=$1
    local out_path=$2
    local c_mis=$3
    local batch=$4
    local map=$5
    local threads=$6
    
    get_version 'cstacks'
    if [ ! -z "$cgap" ];
    then
        if [ "$cgap" == 0 ];
        then
            if [ "$f_ver" == 2 ]; then cgap='--disable_gapped'; else cgap=''; fi
        else
            if [ "$f_ver" == 2 ]; then cgap=''; fi
        fi
    fi
    
    cstacks -P $in_path -M $map -n $c_mis $cgap -p $threads 2>&1 | tee $out_path/Cstacks.log
    tt=`grep 'cstacks is done.' $out_path/Cstacks.log`
    if [ -z "$tt" ];
    then
        echo "cstacks error!"
        exit 1
    fi
}

check_files() {
    local in_path=$1
    local sa_path=$2
    local len=${#pop[@]}   
    for ((i=0;i<$len;i++));
    do
        indiv=${pop[$i]}
        let j=$i+1
        guess_fmt $in_path $indiv
        check_fmt $in_path $indiv $suffix
        ez=$in_path/$indiv.$suffix
        pe1=$sa_path/${indiv}_1.$suffix
        pe2=$sa_path/${indiv}_2.$suffix
        if [ ! -f "$ez" ] || ([ ! -f "$pe1" ] && [ ! -f "$pe2" ]);
        then
            echo "File name error, please rename files with enzyme cut sites as individual.fq.gz, e.g. indiv1.fq.gz"
            echo "And rename files with random sheared ends as individual_2.fq.gz, e.g. indiv1_2.fq.gz"
            exit 1
        fi
        indivs[$i]=$ez # array for individuals.
        if [ $iter ] && [ $j -lt $len ];
        then
            ftyp=''
        fi
    done
}

###### Preliminary ######

######Set environment ######
cur_path=`which RADassembler`
cur_path=${cur_path%"RADassembler"}
chmod +x $cur_path/bin/*.pl
export PATH=$cur_path/bin:$PATH
if [ ! `which sort_read_pairs_multi.pl 2>/dev/null` ] || [ ! `which CP3_Opti.pl 2>/dev/null` ];
then
    echo "Incompleted installation of RADassembler!"
    exit 1
fi
###### Select similarity threshold ######
if [ "$1" = 'chooseN' ];
then
    chooseN $2 $3 $4 $5 $6 $7 $8 $9
    if [ $?==0 ]; then exit 0; else exit 1; fi
fi
if [ "$1" = 'chooseM' ]; 
then
    chooseM $2 $3 $4 $5 $6 $7 $8 $9
    if [ $?==0 ]; then exit 0; else exit 1; fi
fi

if [ $# -lt 4 ] || [ $1 = -h ];
then 
    echo "$Usage"
    exit 0
fi

###### Default parameters ######
if [ -z "$in_path" ]; then echo "Please indicate input path!"; exit 1; fi
if [ -z "$out_path" ]; then echo "Please indicate out path!"; exit 1; fi
if [ -z "$samp" ]; then echo "Please indicate paired-end file path!"; exit 1; fi
if [ -z "$map" ]; then echo "Please indicate a PopMap file!"; exit 1; fi
if [ -z "$mis" ]; then mis=2; fi
if [ -z "$c_mis" ]; then c_mis=1; fi
if [ -z "$minDP" ]; then minDP=3; fi
if [ -z "$minL" ]; then minL=3; fi
if [ -z "$asmb" ]; then asmb=1; dasmb='Yes'; else dasmb='No'; fi
if [ -z "$threads" ]; then threads=1; fi
if [ -z "$kmer" ]; then kmer=27; fi
if [ -z "$cov" ]; then cov=''; else cov="-c $cov"; fi
if [ -z "$assembler" ]; then assembler='cap3'; elif [ "$assembler" == 'velvet' ]; 
then if [ ! `which velvetg 2>/dev/null` ] || [ ! `which velveth 2>/dev/null` ];
then echo "Please install velvet!"; fi; fi

###### Continue to assembly ######
if [ "$run_flg" == 'assembly' ];
then
    echo "Continue to run assembly..."
    t1=$(date +%s)
    goto assembly
fi 
######################################
if [ -d "$out_path" ];
then 
    echo -e "\033[47;31m Directory [$out_path] exists!\033[0m"
    echo -e "\033[47;31m Do you really want to delete it?\033[0m"
    read con
    if [ "$con" == 'y' ] || [ "$con" == 'yes' ];
    then
        echo "Deleting $out_path..."
        rm -rf $out_path
    elif [ "$con" == 'r' ];
    then
        echo "Continue anyway..."
    else
        echo "Directory exists, Please rename it!"
        exit 1;
    fi
fi
###### Sort reads by Stacks ######
#declare -A pop
#read_popmap $map
read_ind_order $map
mkdir -p $out_path/stacks
len=${#pop[@]}
indivs=()
###### Check Files ######
check_files $in_path $samp
 
###### Single Run #######
if [ "$run_flg" == 'ustacks' ];
then
    echo "Single run of ustacks is starting."
    run_ustacks $out_path $mis $minDP $threads
    if [ $?==0 ]; then echo "Single run of ustacks is done."; exit 0; else exit 1; fi    
fi
if [ "$run_flg" == 'cstacks' ];
then
    echo "Single run of cstacks is starting."
    run_cstacks $in_path $out_path $c_mis 1 $map $threads
    if [ $?==0 ]; then echo "Single run of cstacks is done."; exit 0; else exit 1; fi
fi   
#########################
###### Parameters ######
par="
RADassembler Parameters:
\nNumber  of individuals                 : $len
\nPath of reads for clustering[read1]     : $in_path 
\nPath of reads for assembly[paired-end] : $samp
\nPath of output results                 : $out_path
\nMinimum depth for stacks               : $minDP
\nMismatch[ustacks]                      : $mis
\nMismatch[cstacks]                      : $c_mis
\nNumber of threads                      : $threads
\nAssembly                               : $dasmb
\nAssembler                              : $assembler
\nDepth for assembly                     : $minL
"
echo "======================================================"
echo -e $par | tee $out_path/RADassembler.par
echo "======================================================"
echo
#####################
    
###### Ustacks ######
echo "======================================================"
echo "  [`tcmd`] Running ustacks..."
echo "======================================================"
t1=$(date +%s)
run_ustacks $out_path $mis $minDP $threads
if [ $? != 0 ];
then
    exit 1;
fi
#################################
running_time ustacks
###### cstacks and sstacks ######
echo "======================================================"
echo "  [`tcmd`] Running cstacks..."
echo "======================================================"
run_cstacks $out_path/stacks $out_path/stacks $c_mis 1 $map $threads
if [ $? != 0 ];
then
    exit 1;
fi
running_time cstacks

###### Continue to run assembly by flag ######
#assembly:
echo "======================================================"
echo "  [`tcmd`] Running sstacks..."
echo "======================================================"
sstacks -P $out_path/stacks/ -M $map -p $threads 2>&1 | tee $out_path/stacks/Sstacks.log
tt=`grep 'sstacks is done.' $out_path/stacks/Sstacks.log`
if [ -z "$tt" ];
then
    echo "sstacks error!"
    exit 1
fi
running_time sstacks
###############################
###### export read pairs ######
echo "==========================================================="
echo "  [`tcmd`] Exporting fasta files..."
echo "==========================================================="
if [ -d "$out_path/reads_export" ];
then
    echo -e "\033[47;31m Directory [$out_path/reads_export] exists \033[0m"
    echo -e "\033[47;31m Do you want to delete it ? y/n \033[0m"
    read con
    if [ "$con" == 'y' ] || [ "$con" == 'yes' ];
    then
        echo "Deleting $out_path/reads_export..."
        rm -rf $out_path/reads_export
    elif [ "$con" == 'r' ];
    then
        echo "Continue anyway..."
    else
        echo "Directory exists, please rename it."
        exit 1;
    fi
fi
mkdir -p $out_path/reads_export
sort_read_pairs_multi.pl -p $out_path/stacks/ -s $samp -o $out_path/reads_export -T $threads -m $minL -i ${ftyp#"gz"} $cov 2>&1 | tee $out_path/stacks/export.log
if [ $? != 0 ];
then
    echo "Error in exporting fasta files, exiting..."
    exit 1;
fi
##########################
running_time 'exporting fasta'
###### run assembly ######
if [ "$asmb" == 1 ];
then
    echo "==========================================================="
    echo "  [`tcmd`] Running local assembly..."
    echo "==========================================================="
    CP3_Opti.pl -i $out_path/reads_export -o $out_path/Assembly -l $out_path/stacks/*catalog.tags.tsv* -a $assembler -t $threads -k $kmer
    if [ $? != 0 ];
    then
        echo "Error in local assembly, exiting..."
        exit 1;
    fi
fi
running_time Assembly
echo "[`tcmd`] Done!"
t2=$(date +%s)
echo "Total running time is $(( $t2 - $t0 )) s"
